非线程安全是多个线程对同一个对象中的实例变量进行访问操作等等,会出现一种数据脏读的结果.
处理线程安全问题简单的说就是处理一个对象中实例变量的同步操作,跟数据库事务一个道理.
线程安全问题只会出现在实例变量中,一个方法中的私有变量是不会发生线程安全问题的.

当出现多个线程共享一个对象中的实例时,会出现非线程安全问题,数据覆盖,数据脏读订单.那么怎么解决呢?
    只要在方法前面加上synchronized关键字即可,这样表明了方法同步,那么会防止线程安全问题
    这里用synchronized解决线程安全问题只能是用同一把锁.
    如果用多个对象多把锁,那其实是没有意义的,即自己给自己的私人钱包加了个密码,都是私有各自使用,那么也不存在线程安全问题。这个不是解决方式
    
使用synchronized即同步的概念,所以运行一定会排队,所以要使用synchronized要明确资源是否要共享,或者可能会出现线程安全问题,要谨慎使用

前面说的使用synchronized就可以避免线程安全问题,那是针对一个方法的,那如果出现读写分离的情况,一个同步,一个不同步,那么也会出现脏读现象
所以出现这种情况的时候,多个操作都得加锁,都得按同步的方式一个一个的执行,才能避免线程安全问题
这也说明了脏读一定会出现在操作实力变量的情况下,这就是多个线程争抢同一个实例资源导致的结果


