非线程安全是多个线程对同一个对象中的实例变量进行访问操作等等,会出现一种数据脏读的结果.
处理线程安全问题简单的说就是处理一个对象中实例变量的同步操作,跟数据库事务一个道理.
线程安全问题只会出现在实例变量中,一个方法中的私有变量是不会发生线程安全问题的.

当出现多个线程共享一个对象中的实例时,会出现非线程安全问题,数据覆盖,数据脏读订单.那么怎么解决呢?
    只要在方法前面加上synchronized关键字即可,这样表明了方法同步,那么会防止线程安全问题
    这里用synchronized解决线程安全问题只能是用同一把锁.
    如果用多个对象多把锁,那其实是没有意义的,即自己给自己的私人钱包加了个密码,都是私有各自使用,那么也不存在线程安全问题。这个不是解决方式
    
使用synchronized即同步的概念,所以运行一定会排队,所以要使用synchronized要明确资源是否要共享,或者可能会出现线程安全问题,要谨慎使用

前面说的使用synchronized就可以避免线程安全问题,那是针对一个方法的,那如果出现读写分离的情况,一个同步,一个不同步,那么也会出现脏读现象
所以出现这种情况的时候,多个操作都得加锁,都得按同步的方式一个一个的执行,才能避免线程安全问题
这也说明了脏读一定会出现在操作实力变量的情况下,这就是多个线程争抢同一个实例资源导致的结果

synchronized锁重入,当一个线程到一个对象的锁的时候,再次请求改对象的锁的时候是可以再次得到这个锁的.即在同步方法/块调用本类中的其他同步方法/块,将永远获得锁
锁重入的深入,我获取了一个对象的锁,这时候我还没有释放这把锁,但是我又想获取这个对象的锁,还是可以获取的.变相的理解,这把锁一直是自己在使用,没有其他的跟他争抢
所以就可以永远使用. 如果锁重入不被允许时,那么这时候就会造成死锁
可重入锁不仅支持本来,还支持父子类的继承环境

出现异常,同步锁会自动释放

同步是不具备继承性的,即父类的方法是同步的,只有用到父类运行改方法才是同步的,子类的方法是不同步的,要想同步只能加上synchronized关键字

synchronized











